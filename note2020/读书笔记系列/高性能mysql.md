# 一、Mysql历史与架构

## 1.1 逻辑架构图

```
                    连接/线程处理
                         |
              查询优化  <————   解析器
                       优化器
                         |                    
                      存储引擎
         
```



## 1.2 读锁、写锁

​        读锁也叫共享锁，写锁也叫排他锁。

​        读锁是共享的，互不阻塞，多个用户，可以在同一个时刻读取数据库文件，互不干扰。

​        写锁是排他的，就是说，一个写锁会阻塞其他的写锁以及读锁。

在实际数据库中，每时每刻都在发生锁定，当一个用户在写入或者修改数据时，其他用户将无法读取统一数据（更别说修改了）。但是大多数情况下，锁定的内部管理是透明的（用户察觉不到）。

## 1.3 锁的粒度

​        所谓锁的粒度，就是指锁的作用范围，当我在修改某条数据时，我是把这个数据库的表锁起来，还是锁它所在的行呢。Mysql不同的引擎有着不同的实现方式。

### 1.2.1 表锁

​        表锁是mysql最基本的锁策略，并且是开销最小的策略。对某个表进行插入、删除、更新的时候，需要先获得写锁，然后锁定整张表。

​        在某些场合，表锁也可以拥有不错的性能，例如，READ LOCAL表锁支持某些类型的并发写操作。另外，写锁的优先级大于读锁，写锁可以插队插到读锁前面，而读锁不可以。

​        虽然mysql运行引擎可以管理自己地锁，MySQL本身也会去使用各种有效的表锁来达到自己的目的。比如执行 alter table之类的语句时，会使用表锁。

### 1.2.2 行锁

​        行级锁可以最大程度地支持并发。众所周知，在InnoDB和XtraDB，以及其他的一些存储引擎中实现了行级锁。但也会带来较大地锁地开销

## 1.4 事务

​        事务就是一组原子性的sql执行语句，当这一组中有任意一个sql执行失败，那么所有的语句都不会执行。

​        ACID表示原子性（atomicity），一致性（consistency），隔离性（isolation），持久性（durability）

原子性：一个事务就是一个不可分割的最小工作单元，同生共死

一致性：数据库总是从一个一致性地状态转移到另一个一致性地状态。当事务执行到一半出现错误时，只要还没commit。数据库就不会改变。

隔离性：一个事务所做的修改在最终提交前，对其他的事务是不可见地。比如我这个事务一共四条sql，第二条sql是将数据库中的某个初始值为0的A数据加200，即使现在已经执行到第三个sql了，数据库中的A仍然为0，其他事务看到的数据仍然为0，

持久性：一旦事务提交，数据将会被彻底写到数据库。